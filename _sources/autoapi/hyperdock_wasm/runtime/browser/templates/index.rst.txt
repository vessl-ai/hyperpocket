hyperdock_wasm.runtime.browser.templates
========================================

.. py:module:: hyperdock_wasm.runtime.browser.templates



Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/hyperdock_wasm/runtime/browser/templates/node/index
   /autoapi/hyperdock_wasm/runtime/browser/templates/python/index


Attributes
----------

.. autoapisummary::

   hyperdock_wasm.runtime.browser.templates.node_template
   hyperdock_wasm.runtime.browser.templates.python_template
   hyperdock_wasm.runtime.browser.templates.TemplateEnvironments


Functions
---------

.. autoapisummary::

   hyperdock_wasm.runtime.browser.templates.render


Package Contents
----------------

.. py:data:: node_template
   :value: Multiline-String

   .. raw:: html

      <details><summary>Show Value</summary>

   .. code-block:: python

      """
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>PyScript Offline</title>
      </head>
      <body>
      <script type="module">
          function loadConfig() {
              globalThis.toolConfigs = {
                  envs: `{{ ENV_JSON }}`,
                  body: `{{ BODY_JSON_B64 }}`,
                  scriptID: `{{ SCRIPT_ID }}`
              }
          }
          import { WebContainer } from 'https://esm.run/@webcontainer/api@1.5.1';
          function decodeContent(content) {
              return Uint8Array.from(atob(content), c => c.charCodeAt(0));
          }
          function decodeFileTree(filetree) {
              const decoded = {};
              for (const [key, value] of Object.entries(filetree)) {
                  if (value.file) {
                      decoded[key] = {
                          file: {
                              contents: decodeContent(value.file.contents)
                          }
                      }
                  } else if (value.directory) {
                      decoded[key] = {
                          directory: decodeFileTree(value.directory)
                      }
                  } else if (value.symlink) {
                      decoded[key] = {
                          symlink: value.symlink
                      }
                  }
              }
              return decoded;
          }
          
          async function _main() {
              loadConfig();
              const b64FilesResp = await fetch(`/scripts/${globalThis.toolConfigs.scriptID}/file_tree`);
              const b64Files = await b64FilesResp.json();
              const files = decodeFileTree(b64Files.tree);
              const webcontainer = await WebContainer.boot();
              
              await webcontainer.mount(files)
              const envs = JSON.parse(globalThis.toolConfigs.envs)
              envs['DEPLOYED'] = 'true'
              const runProcess = await webcontainer.spawn('node', ['dist/index.js'], {
                  output: true,
                  env: envs,
              });
              const stdin = runProcess.input.getWriter();
              const decodedBytes = atob(globalThis.toolConfigs.body);
              await (async () => {
                  await stdin.ready
                  await stdin.write(decodedBytes);
              })()
              let stdout = '';
              runProcess.output.pipeTo(
                  new WritableStream({
                      write(chunk) {
                          stdout += chunk;
                      }
                  })
              )
              await runProcess.exit;
              if (stdout.startsWith(decodedBytes)) {
                  stdout = stdout.slice(decodedBytes);
              }
              await fetch(`/scripts/${globalThis.toolConfigs.scriptID}/done`, {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({ stdout })
              });
          }
          
          async function main() {
              try {
                  await _main();
              } catch (e) {
                  console.error(e);
                  await fetch(`/scripts/${globalThis.toolConfigs.scriptID}/done`, {
                      method: 'POST',
                      headers: {
                          'Content-Type': 'application/json'
                      },
                      body: JSON.stringify({ error: e.message })
                  });
              }
          }
          
          main();
      </script>
      </body>
      </html>
      """

   .. raw:: html

      </details>



.. py:data:: python_template
   :value: Multiline-String

   .. raw:: html

      <details><summary>Show Value</summary>

   .. code-block:: python

      """
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>PyScript Offline</title>
          <script src="https://cdn.jsdelivr.net/pyodide/v0.26.4/full/pyodide.js"></script>
      </head>
      <body>
      <script type="module">
          function loadConfig() {
              globalThis.toolConfigs = {
                  envs: `{{ ENV_JSON }}`,
                  body: `{{ BODY_JSON_B64 }}`,
                  scriptID: `{{ SCRIPT_ID }}`
              }
          }
          async function _main() {
              // load the script configs
              loadConfig();
              
              // get entrypoint wheel
              const entrypointResp = await fetch(`/scripts/${globalThis.toolConfigs.scriptID}/entrypoint`);
              const { package_name: packageName, entrypoint } = await entrypointResp.json();
              
              // initialize pyodide
              const pyodide = await loadPyodide({
                  env: JSON.parse(globalThis.toolConfigs.envs),
              });
              await pyodide.loadPackage("micropip");
              await pyodide.loadPackage("ssl");
              const micropip = pyodide.pyimport("micropip");
              await micropip.install(entrypoint);
              await micropip.install("pyodide-http")
              
              let emitted = false;
              const decodedBytes = atob(globalThis.toolConfigs.body);
              pyodide.setStdin({
                  stdin: () => {
                      if (emitted) {
                          return null;
                      }
                      emitted = true;
                      return decodedBytes;
                  },
                  autoEOF: true,
              })
              let stdout = "";
              let stderr = "";
              pyodide.setStdout({
                  batched: (x) => { stdout += x; },
              })
              pyodide.setStderr({
                  batched: (x) => { stderr += x; },
              })
              await pyodide.runPythonAsync(`
      import pyodide_http
      pyodide_http.patch_all()
      
      import ${packageName}
      ${packageName}.main()
      `);
              console.log(stdout)
              await fetch(`/scripts/${globalThis.toolConfigs.scriptID}/done`, {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({ stdout, stderr })
              });
          }
          
          async function main() {
              try {
                  await _main();
              } catch (e) {
                  console.error(e);
                  await fetch(`/scripts/${globalThis.toolConfigs.scriptID}/done`, {
                      method: 'POST',
                      headers: {
                          'Content-Type': 'application/json'
                      },
                      body: JSON.stringify({ error: e.message })
                  });
              }
          }
          
          main();
      </script>
      </body>
      </html>
      """

   .. raw:: html

      </details>



.. py:data:: TemplateEnvironments

.. py:function:: render(language: str, script_id: str, env: dict[str, str], body: str, **kwargs) -> str

